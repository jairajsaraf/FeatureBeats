"""
Data models for Spotify track data.

This module defines the schema for Spotify track data from the Kaggle dataset:
https://www.kaggle.com/datasets/ektanegi/spotifydata-19212020
"""

from datetime import date
from typing import Optional, List
from pydantic import BaseModel, Field, field_validator, ConfigDict


class SpotifyTrack(BaseModel):
    """
    Model representing a Spotify track with all its features.

    Dataset contains 169k songs from 1921-2020, with top 100 songs per year.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
    )

    # Primary identifier
    id: str = Field(..., description="Unique track ID generated by Spotify")

    # Categorical fields
    name: str = Field(..., description="Name of the song")
    artists: str = Field(..., description="List of artists mentioned")
    release_date: str = Field(..., description="Date of release (yyyy-mm-dd format, precision may vary)")

    # Numerical features (0-1 range)
    acousticness: float = Field(..., ge=0.0, le=1.0, description="Acoustic quality of the track")
    danceability: float = Field(..., ge=0.0, le=1.0, description="How suitable track is for dancing")
    energy: float = Field(..., ge=0.0, le=1.0, description="Measure of intensity and activity")
    instrumentalness: float = Field(..., ge=0.0, le=1.0, description="Predicts if track has no vocals")
    liveness: float = Field(..., ge=0.0, le=1.0, description="Presence of audience in recording")
    speechiness: float = Field(..., ge=0.0, le=1.0, description="Presence of spoken words")
    valence: float = Field(..., ge=0.0, le=1.0, description="Musical positiveness/happiness")

    # Other numerical features
    duration_ms: int = Field(..., gt=0, description="Track duration in milliseconds")
    popularity: int = Field(..., ge=0, le=100, description="Popularity score (0-100)")
    tempo: float = Field(..., gt=0, description="Estimated tempo in BPM")
    loudness: float = Field(..., description="Overall loudness in dB (typically -60 to 0)")
    year: int = Field(..., ge=1921, le=2025, description="Release year")

    # Categorical as integer
    key: int = Field(..., ge=0, le=11, description="Musical key (0=C, 1=C#, ..., 11=B)")

    # Binary/dummy variables
    mode: int = Field(..., ge=0, le=1, description="0 = Minor, 1 = Major")
    explicit: int = Field(..., ge=0, le=1, description="0 = No explicit content, 1 = Explicit")

    @field_validator('release_date')
    @classmethod
    def validate_release_date(cls, v: str) -> str:
        """Validate release date format (flexible to handle varying precision)."""
        if not v:
            raise ValueError("Release date cannot be empty")
        # Accept various formats: yyyy, yyyy-mm, yyyy-mm-dd
        parts = v.split('-')
        if len(parts) not in [1, 2, 3]:
            raise ValueError(f"Invalid release date format: {v}")
        return v

    @field_validator('artists')
    @classmethod
    def validate_artists(cls, v: str) -> str:
        """Validate artists field is not empty."""
        if not v or v.strip() == '':
            raise ValueError("Artists cannot be empty")
        return v.strip()

    def get_musical_key_name(self) -> str:
        """Convert key integer to musical note name."""
        keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
        return keys[self.key]

    def get_mode_name(self) -> str:
        """Get mode name (Major/Minor)."""
        return 'Major' if self.mode == 1 else 'Minor'

    def is_explicit(self) -> bool:
        """Check if track has explicit content."""
        return self.explicit == 1

    def get_duration_seconds(self) -> float:
        """Get duration in seconds."""
        return self.duration_ms / 1000.0

    def get_duration_minutes(self) -> float:
        """Get duration in minutes."""
        return self.duration_ms / 60000.0

    def get_artists_list(self) -> List[str]:
        """
        Parse artists string into list.
        Handles common formats like "['Artist1', 'Artist2']" or "Artist1, Artist2".
        """
        import ast

        # Try to parse as Python list literal
        try:
            artists_list = ast.literal_eval(self.artists)
            if isinstance(artists_list, list):
                return [str(a).strip() for a in artists_list]
        except (ValueError, SyntaxError):
            pass

        # Fallback: split by comma
        return [a.strip() for a in self.artists.split(',')]

    @property
    def decade(self) -> int:
        """Get the decade of the track (e.g., 1980 for songs from 1980-1989)."""
        return (self.year // 10) * 10

    @property
    def era(self) -> str:
        """Categorize track into musical era."""
        if self.year < 1950:
            return "Pre-1950s"
        elif self.year < 1960:
            return "1950s"
        elif self.year < 1970:
            return "1960s"
        elif self.year < 1980:
            return "1970s"
        elif self.year < 1990:
            return "1980s"
        elif self.year < 2000:
            return "1990s"
        elif self.year < 2010:
            return "2000s"
        elif self.year < 2020:
            return "2010s"
        else:
            return "2020s"


class SpotifyDatasetStats(BaseModel):
    """Statistics about the Spotify dataset."""

    total_tracks: int
    unique_artists: int
    year_range: tuple[int, int]
    avg_duration_ms: float
    avg_popularity: float
    avg_tempo: float
    most_common_key: int
    most_common_mode: int
    explicit_percentage: float
